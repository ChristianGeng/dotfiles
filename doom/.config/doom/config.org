#+TITLE: Doom Emacs Config
#+AUTHOR: Christian Geng, based on DT's configuration
#+DESCRIPTION: cgeng's personal Doom Emacs config.
#+STARTUP: showeverything

* TABLE OF CONTENTS :toc:
- [[#about-this-config][ABOUT THIS CONFIG]]
- [[#vimevil-cheatsheet][VIM/EVIL CHEATSHEET]]
- [[#0-definitions][0-DEFINITIONS]]
  - [[#emacs-directories][Emacs Directories]]
  - [[#org-directory][Org-Directory]]
- [[#bookmarks-and-buffers][BOOKMARKS AND BUFFERS]]
  - [[#bookmarks][Bookmarks]]
  - [[#global-auto-revert][Global Auto Revert]]
  - [[#keybindings-within-ibuffer-mode][Keybindings within ibuffer mode]]
- [[#dired][DIRED]]
  - [[#keybindings][Keybindings]]
  - [[#keybindings-within-dired][Keybindings Within Dired]]
  - [[#specify-whether-to-use-trash-can][Specify whether to use trash can]]
- [[#editing-functions][EDITING FUNCTIONS]]
  - [[#semantic-line-breaks][Semantic Line Breaks]]
- [[#imenu][IMENU]]
- [[#emms][EMMS]]
- [[#line-settings][LINE SETTINGS]]
- [[#markdown][MARKDOWN]]
- [[#minimap][MINIMAP]]
- [[#menubartoolbar][MENUBAR/TOOLBAR]]
- [[#modeline][MODELINE]]
- [[#mouse-support][MOUSE SUPPORT]]
- [[#neotree][NEOTREE]]
- [[#open-specific-files][OPEN SPECIFIC FILES]]
- [[#org-mode][ORG MODE]]
  - [[#org-agenda][Org-agenda]]
  - [[#org-journal][Org-Journal]]
  - [[#org-and-latex-inline-images][Org and latex inline images]]
  - [[#org-roam][Org-roam]]
  - [[#other-exporters][Other exporters]]
  - [[#org-auto-tangle][Org-auto-tangle]]
- [[#perspective][PERSPECTIVE]]
- [[#project][Project]]
- [[#lsp-language-server-protocol][LSP (Language Server Protocol)]]
  - [[#general-lsp-configuration][General LSP Configuration]]
  - [[#lsp-ui-configuration][LSP UI Configuration]]
  - [[#language-specific-lsp-settings][Language-Specific LSP Settings]]
- [[#python][Python]]
- [[#rainbow-mode][RAINBOW MODE]]
- [[#registers][REGISTERS]]
- [[#shells][SHELLS]]
- [[#search][Search]]
- [[#start-page][START PAGE]]
- [[#theming][THEMING]]
- [[#treesitter][TREESITTER]]
- [[#winner-mode][WINNER MODE]]
- [[#zap-to-char][ZAP TO CHAR]]
- [[#other-file-stuff][OTHER FILE STUFF]]
- [[#pass---manage-secrets-using-the-default-unix-password-manager][PASS - Manage Secrets using the default unix password manager]]
  - [[#using-pass][Using Pass]]
  - [[#idempotently-insert-keys-into-pass-store][Idempotently insert keys into pass store]]
  - [[#pass-end-environment-variables-from-env][PASS end environment variables from ENV]]
  - [[#migration-to-better-hierarchy][MIGRATION to better hierarchy]]
- [[#ailmms][AI/LMMS]]
  - [[#github-copilot-configuration][Github Copilot Configuration]]
  - [[#aidermacs-configuration][AIdermacs Configuration]]
  - [[#ai-rules-system-similar-to-cursorrules][AI Rules system (Similar to .cursorrules)]]
  -  [[#enhanced-ai-functions-with-rules-support][Enhanced AI functions with rules support]]
  - [[#integrated-ai-workflow-functions][Integrated AI workflow functions]]
  - [[#enhanced-keybindings-with-rules-support][Enhanced Keybindings with Rules Support]]
  - [[#optional-performance-and-ux-improvements][Optional: Performance and UX Improvements]]
  - [[#startup-configuration][Startup Configuration]]
- [[#yasnippet][YASNIPPET]]

* ABOUT THIS CONFIG
:PROPERTIES:
:END:

This is my personal Doom Emacs configuration.

* VIM/EVIL CHEATSHEET
:PROPERTIES:
:END:

For a quick reference of Vim/Evil mode keybindings, see the [[file:./cheatsheet.org][cheatsheet.org]] file.
 this seems to be the way to go in emacs right right now.

* 0-DEFINITIONS

** Emacs Directories
I want to use parts of the code from my old emacs configuration.
This above all involves my lisp function.
~user-emacs-directory~ is "/home/cgeng/doom-emacs/.local/cache/" in doom emacs.
and "~/emacs-conf/" in ~emacs-default~.

#+begin_src emacs-lisp
  ;; Functions (load all files in defuns-dir)
  (setq defuns-dir (expand-file-name "defuns" doom-user-dir))
  (dolist (file (directory-files defuns-dir t "^[^.#].*el$"))
    (when (file-regular-p file)
      (load (file-name-sans-extension file))))
#+end_src

** Org-Directory
#+begin_src emacs-lisp
(setq org-directory "~/Dropbox/org")
#+end_src


* BOOKMARKS AND BUFFERS
Doom Emacs uses 'SPC b' for keybindings related to bookmarks and buffers.

** Bookmarks
Bookmarks are somewhat like registers in that they record positions you can jump to.  Unlike registers, they have long names, and they persist automatically from one Emacs session to the next. The prototypical use of bookmarks is to record where you were reading in various files.

| COMMAND         | DESCRIPTION                            | KEYBINDING |
|-----------------+----------------------------------------+------------|
| list-bookmarks  | /List bookmarks/                         | SPC b L    |
| bookmark-set    | /Set bookmark/                           | SPC b m    |
| bookmark-delete | /Delete bookmark/                        | SPC b M    |
| bookmark-save   | /Save current bookmark to bookmark file/ | SPC b w    |

#+BEGIN_SRC emacs-lisp
(setq bookmark-default-file "~/.config/doom/bookmarks")

(map! :leader
      (:prefix ("b". "buffer")
       :desc "List bookmarks"                          "L" #'list-bookmarks
       :desc "Set bookmark"                            "m" #'bookmark-set
       :desc "Delete bookmark"                         "M" #'bookmark-set
       :desc "Save current bookmarks to bookmark file" "w" #'bookmark-save))
#+END_SRC

** Global Auto Revert
A buffer can get out of sync with respect to its visited file on disk if that file is changed by another program. To keep it up to date, you can enable Auto Revert mode by typing M-x auto-revert-mode, or you can set it to be turned on globally with 'global-auto-revert-mode'.  I have also turned on Global Auto Revert on non-file buffers, which is especially useful for 'dired' buffers.

#+begin_src emacs-lisp
(global-auto-revert-mode 1)
(setq global-auto-revert-non-file-buffers t)
#+end_src

** Keybindings within ibuffer mode
| COMMAND                           | DESCRIPTION                            | KEYBINDING |
|-----------------------------------+----------------------------------------+------------|
| ibuffer-mark-forward              | /Mark the buffer/                        | m          |
| ibuffer-unmark-forward            | /Unmark the buffer/                      | u          |
| ibuffer-do-kill-on-deletion-marks | /Kill the marked buffers/                | x          |
| ibuffer-filter-by-content         | /Ibuffer filter by content/              | f c        |
| ibuffer-filter-by-directory       | /Ibuffer filter by directory/            | f d        |
| ibuffer-filter-by-filename        | /Ibuffer filter by filename (full path)/ | f f        |
| ibuffer-filter-by-mode            | /Ibuffer filter by mode/                 | f m        |
| ibuffer-filter-by-name            | /Ibuffer filter by name/                 | f n        |
| ibuffer-filter-disable            | /Disable ibuffer filter/                 | f x        |
| ibuffer-do-kill-lines             | /Hide marked buffers/                    | g h        |
| ibuffer-update                    | /Restore hidden buffers/                 | g H        |

#+begin_src emacs-lisp
(evil-define-key 'normal ibuffer-mode-map
  (kbd "f c") 'ibuffer-filter-by-content
  (kbd "f d") 'ibuffer-filter-by-directory
  (kbd "f f") 'ibuffer-filter-by-filename
  (kbd "f m") 'ibuffer-filter-by-mode
  (kbd "f n") 'ibuffer-filter-by-name
  (kbd "f x") 'ibuffer-filter-disable
  (kbd "g h") 'ibuffer-do-kill-lines
  (kbd "g H") 'ibuffer-update)
#+end_src

* DIRED

Dired is the file manager within Emacs.
I do not like ~SPC  d d~ bindings and have removed them
as they collide with doom's ~dape~ menu that is under ~~SPC d~.
~SPC o -~ already exists and also allows to access dired.

~peep-dired~ opens too many windows side-by-side.
I have also removed it.

** Keybindings

| COMMAND    | DESCRIPTION                                          | KEYBINDING |
|------------+------------------------------------------------------+------------|
| dired-jump | Jump to Dired buffer corresponding to current buffer | SPC  o -   |
| dired      | /Open dired file manager/                              | C-x d      |

** Keybindings Within Dired
*** Basic dired commands

| COMMAND                | DESCRIPTION                                 | KEYBINDING |
|------------------------+---------------------------------------------+------------|
| dired-up-directory     | /Go up in directory tree/                     | h          |
| dired-find-file        | /Go down in directory tree (or open if file)/ | l          |
| dired-next-line        | /Move down to next line/                      | j          |
| dired-previous-line    | /Move up to previous line/                    | k          |
| dired-mark             | /Mark file at point/                          | m          |
| dired-unmark           | /Unmark file at point/                        | u          |
| dired-do-copy          | /Copy current file or marked files/           | C          |
| dired-do-rename        | /Rename current file or marked files/         | R          |
| dired-hide-details     | /Toggle detailed listings on/off/             | (          |
| dired-git-info-mode    | /Toggle git information on/off/               | )          |
| dired-create-directory | /Create new empty directory/                  | +          |
| dired-diff             | /Compare file at point with another/          | =          |
| dired-subtree-toggle   | /Toggle viewing subtree at point/             | TAB        |


*** Dired commands using regex

| COMMAND                      | DESCRIPTION                                      | KEYBINDING |
|------------------------------+--------------------------------------------------+------------|
| dired-do-shell-command       | Run shell command on marked files                | !          |
| dired-do-async-shell-command | Run shell command asynchronously on marked files | &          |
| dired-mark-files-regexp      | /Mark files using regex/                           | % m        |
| dired-do-copy-regexp         | /Copy files using regex/                           | % C        |
| dired-do-rename-regexp       | /Rename files using regex/                         | % R        |
| dired-mark-files-regexp      | /Mark all files using regex/                       | * %        |

- ~!~ on a marked file guesses what to do with the file: ~xdg-open~  is the guess. Not working with ~&~.

*** File permissions and ownership

| COMMAND         | DESCRIPTION                      | KEYBINDING |
|-----------------+----------------------------------+------------|
| dired-do-chgrp  | /Change the group of marked files/ | g G        |
| dired-do-chmod  | /Change the mode of marked files/  | M          |
| dired-do-chown  | /Change the owner of marked files/ | O          |
| dired-do-rename | /Rename file or all marked files/  | R          |

#+begin_src emacs-lisp
(evil-define-key 'normal dired-mode-map
  (kbd "M-RET") 'dired-display-file
  (kbd "h") 'dired-up-directory
  (kbd "l") 'dired-open-file ; use dired-find-file instead of dired-open.
  (kbd "m") 'dired-mark
  (kbd "t") 'dired-toggle-marks
  (kbd "u") 'dired-unmark
  (kbd "C") 'dired-do-copy
  (kbd "D") 'dired-do-delete
  (kbd "J") 'dired-goto-file
  (kbd "M") 'dired-do-chmod
  (kbd "O") 'dired-do-chown
  (kbd "P") 'dired-do-print
  (kbd "R") 'dired-do-rename
  (kbd "T") 'dired-do-touch
  (kbd "Y") 'dired-copy-filenamecopy-filename-as-kill ; copies filename to kill ring.
  (kbd "Z") 'dired-do-compress
  (kbd "+") 'dired-create-directory
  (kbd "-") 'dired-do-kill-lines
  (kbd "% l") 'dired-downcase
  (kbd "% m") 'dired-mark-files-regexp
  (kbd "% u") 'dired-upcase
  (kbd "* %") 'dired-mark-files-regexp
  (kbd "* .") 'dired-mark-extension
  (kbd "* /") 'dired-mark-directories
  (kbd "; d") 'epa-dired-do-decrypt
  (kbd "; e") 'epa-dired-do-encrypt)
;; Get file icons in dired
;; (add-hook 'dired-mode-hook 'all-the-icons-dired-mode)
;; With dired-open plugin, you can launch external programs for certain extensions
;; For example, I set all .png files to open in 'sxiv' and all .mp4 files to open in 'mpv'
;; sudo apt install sxiv
;; sudo apt install mpv
(setq dired-open-extensions '(("gif" . "sxiv")
                              ("jpg" . "sxiv")
                              ("png" . "sxiv")
                              ("mkv" . "mpv")
                              ("mp4" . "mpv")))

(setq dired-guess-shell-alist-user '(("\\.pdf\\'" "okular")))
(setq dired-guess-shell-alist-user '(("\\.png\'" "sxiv")))
#+end_src

** Specify whether to use trash can

Set to ~t~ if trash can use is desired.

#+begin_src emacs-lisp
(setq delete-by-moving-to-trash nil
      trash-directory "~/.local/share/Trash/files/")
#+end_src

=NOTE=: For convenience, you may want to create a symlink to 'local/share/Trash' in your home directory:
#+begin_example
cd ~/
ln -s ~/.local/share/Trash .
#+end_example

* EDITING FUNCTIONS

TODO: Should be moved to =editing-defuns=!

** Semantic Line Breaks

Using =after-save= hooks is not really useful!

*** Semantic fill region
In 99% of the usecases only the =dwim= version will be required.

#+begin_src emacs-lisp
;; Core function: not interactive, works on any region
(defun cg/semantic-fill-region (start end)
  "Apply semantic fill to region from START to END."
  (let ((fill-column 80))
    (fill-region start end)))

;; Interactive wrapper: acts on region if active, otherwise whole buffer
(defun cg/semantic-fill-dwim ()
  "Semantic fill: region if active, else whole buffer."
  (interactive)
  (if (use-region-p)
      (cg/semantic-fill-region (region-beginning) (region-end))
    (cg/semantic-fill-region (point-min) (point-max))))

;; Explicitly for whole buffer
(defun cg/semantic-fill-buffer ()
  "Semantic fill for the entire buffer."
  (interactive)
  (cg/semantic-fill-region (point-min) (point-max)))

;; Explicitly for region (errors if no region)
(defun cg/semantic-fill-region-interactive (start end)
  "Semantic fill for active region."
  (interactive "r")
  (cg/semantic-fill-region start end))
#+end_src

*** Semantic Line breaks

Test sentences:

Dr. Smith went to Washington, D.C. in 2023. He met with Prof. Johnson; they discussed the project: "Semantic line breaks in Emacs." The meeting was productive! Afterwards, they visited www.example.com. Next, they had lunch at 12:30 p.m. and then returned to the lab.

The experiment started at 9:00. The participants read the instructions carefully; they asked several questions. Data collection began promptly. Results were analyzed using Python. The findings were significant!

The first sentence will not give such good result, the second does.

#+begin_src emacs-lisp
(defun cg/naive-semantic-line-breaks-region (start end)
  "Insert line breaks after sentence-ending punctuation followed by a capital letter."
  (save-excursion
    (goto-char start)
    (while (re-search-forward "\\([\\.\\?!]\\)[ \t]+\\([A-Z]\\)" end t)
      (replace-match (concat "\\1\n\\2")))))


;; Interactive wrapper: region if active, else whole buffer
(defun cg/naive-semantic-line-breaks-dwim ()
  "Semantic line break: region if active, else whole buffer."
  (interactive)
  (if (use-region-p)
      (cg/naive-semantic-line-breaks-region (region-beginning) (region-end))
    (cg/naive-semantic-line-breaks-region (point-min) (point-max))))
#+end_src

*** Line breaking for commands

#+begin_src  emacs-lisp

(defun cg/break-command-args-region (start end)
  "Break shell command in region from START to END into multiple lines.
Each command line option (starting with '-') and its argument(s) will go on
their own line, prefixed with a backslash for shell line continuation.

Non-option arguments appearing after the command are also split onto their
own lines.

Continuation lines are indented with 4 spaces.

Example input:

  python test_memory_conversation.py --worker-url http://localhost:8001 --scenario landmarks extraArg

Example output:

  python test_memory_conversation.py \\
      --worker-url http://localhost:8001 \\
      --scenario landmarks \\
      extraArg

If called interactively with no active region, operates on entire buffer."
  (interactive "r")
  (unless (use-region-p)
    (setq start (point-min)
          end (point-max)))
  (save-excursion
    (let* ((cmd-line (buffer-substring-no-properties start end))
           (tokens (split-string cmd-line "[ \t\n]+" t))
           (indent-str "    ")  ;; fixed 4 space indent
           (inhibit-read-only t))
      (delete-region start end)
      (goto-char start)
      ;; Insert the initial command (first token)
      (when tokens
        (insert (pop tokens)))
      ;; Process all remaining tokens
      (while tokens
        (let ((tok (pop tokens)))
          (if (or (string-prefix-p "-" tok) (string-prefix-p "--" tok))
              ;; If option, insert backslash + newline + fixed indent + option
              (insert (format " \\\n%s%s" indent-str tok))
            ;; else argument: insert space + token
            (insert (format " %s" tok))))))))

;; DWIM interactive wrapper
(defun cg/break-command-args-dwim ()
  "Break command args in region if active, else entire buffer."
  (interactive)
  (if (use-region-p)
      (cg/break-command-args-region (region-beginning) (region-end))
    (cg/break-command-args-region (point-min) (point-max))))

#+end_src

* IMENU
Imenu produces menus for accessing locations in documents, typically in the
current buffer. You can access the locations using an ordinary menu (menu bar or
other) or using minibuffer completion, or you can install 'imenu-list' and have
the imenu displayed as a vertical split that you can toggle show/hide.

| COMMAND                 | DESCRIPTION                      | KEYBINDING |
|-------------------------+----------------------------------+------------|
| consult-imenu           | /Menu to jump to places in buffer/ | gO         |
| consult-imenu-multi     | respects all buffers in project  | SPC s I    |
| imenu-list-smart-toggle | /Toggle imenu shown in a sidebar/  | SPC t i    |

#+BEGIN_SRC emacs-lisp
(setq imenu-list-focus-after-activation t)

(map! :leader
      (:prefix ("t" . "Toggle")
       :desc "Toggle imenu shown in a sidebar" "i" #'imenu-list-smart-toggle))

#+END_SRC
* EMMS

| COMMAND               | DESCRIPTION                     | KEYBINDING |
|-----------------------+---------------------------------+------------|
| emms-pause            | /Pause the track/                 | SPC e x    |
| emms-stop             | /Stop the track/                  | SPC e s    |
| emms-previous         | /Play previous track in playlist/ | SPC e p    |
| emms-playlist-mode-go | /Switch to the playlist buffer/   | SPC e a    |
| emms-next             | /Play next track in playlist/     | SPC e n    |


#+begin_src emacs-lisp
(emms-all)
(emms-default-players)
(emms-mode-line 1)
(emms-playing-time 1)
(setq emms-source-file-default-directory "/media/cgeng/TOSHIBA EXT/mp3"
      emms-playlist-buffer-name "*Music*"
      emms-info-asynchronously t
      emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find)
(map! :leader
      (:prefix ("e" . "EMMS audio player")
       :desc "Go to emms playlist"      "a" #'emms-playlist-mode-go
       :desc "Emms pause track"         "x" #'emms-pause
       :desc "Emms stop track"          "s" #'emms-stop
       :desc "Emms play previous track" "p" #'emms-previous
       :desc "Emms play next track"     "n" #'emms-next))
#+end_src

* LINE SETTINGS
I set comment-line to 'SPC TAB TAB' which is a rather comfortable keybinding for me on my ZSA Moonlander keyboard.  The standard Emacs keybinding for comment-line is 'C-x C-;'.  The other keybindings are for commands that toggle on/off various line-related settings.  Doom Emacs uses 'SPC t' for "toggle" commands, so I choose 'SPC t' plus 'key' for those bindings.

| COMMAND                  | DESCRIPTION                               | KEYBINDING  |
|--------------------------+-------------------------------------------+-------------|
| comment-line             | /Comment or uncomment lines/                | SPC TAB TAB |
| hl-line-mode             | /Toggle line highlighting in current frame/ | SPC t h     |
| global-hl-line-mode      | /Toggle line highlighting globally/         | SPC t H     |
| doom/toggle-line-numbers | /Toggle line numbers/                       | SPC t l     |
| toggle-truncate-lines    | /Toggle truncate lines/                     | SPC t t     |

#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type t)
(map! :leader
      :desc "Comment or uncomment lines"      "TAB TAB" #'comment-line
      (:prefix ("t" . "toggle")
       :desc "Toggle line numbers"            "l" #'doom/toggle-line-numbers
       :desc "Toggle line highlight in frame" "h" #'hl-line-mode
       :desc "Toggle line highlight globally" "H" #'global-hl-line-mode
       :desc "Toggle truncate lines"          "t" #'toggle-truncate-lines))
#+END_SRC

* MARKDOWN

#+begin_src emacs-lisp
(custom-set-faces
 '(markdown-header-face ((t (:inherit font-lock-function-name-face :weight bold :family "variable-pitch"))))
 '(markdown-header-face-1 ((t (:inherit markdown-header-face :height 1.7))))
 '(markdown-header-face-2 ((t (:inherit markdown-header-face :height 1.6))))
 '(markdown-header-face-3 ((t (:inherit markdown-header-face :height 1.5))))
 '(markdown-header-face-4 ((t (:inherit markdown-header-face :height 1.4))))
 '(markdown-header-face-5 ((t (:inherit markdown-header-face :height 1.3))))
 '(markdown-header-face-6 ((t (:inherit markdown-header-face :height 1.2)))))

#+end_src

#+RESULTS:

* MINIMAP
A minimap sidebar displaying a smaller version of the current buffer on either the left or right side. It highlights the currently shown region and updates its position automatically.  Be aware that this minimap program does not work in Org documents.  This is not unusual though because I have tried several minimap programs and none of them can handle Org.

| COMMAND      | DESCRIPTION                               | KEYBINDING |
|--------------+-------------------------------------------+------------|
| minimap-mode | /Toggle minimap-mode/                       | SPC t m    |

#+begin_src emacs-lisp
(setq minimap-window-location 'right)
(map! :leader
      (:prefix ("t" . "toggle")
       :desc "Toggle minimap-mode" "m" #'minimap-mode))
#+end_src

#+RESULTS:
: minimap-mode

* MENUBAR/TOOLBAR

#+begin_src emacs-lisp
(map! :leader
      (:prefix ("t" . "toggle")
       :desc "Toggle menu bar" "M" #'menu-bar-mode))

 (map! :leader
      (:prefix ("t" . "toggle")
       :desc "Toggle menu bar" "T" #'tool-bar-mode))
#+end_src

* MODELINE
The modeline is the bottom status bar that appears in Emacs windows.  For more information on what is available to configure in the Doom modeline, check out:
https://github.com/seagle0128/doom-modeline

#+begin_src emacs-lisp
(set-face-attribute 'mode-line nil :font "Ubuntu Mono-13")
(setq doom-modeline-height 30     ;; sets modeline height
      doom-modeline-bar-width 5   ;; sets right bar width
      doom-modeline-persp-name t  ;; adds perspective name to modeline
      doom-modeline-persp-icon t) ;; adds folder icon next to persp name
#+end_src

* MOUSE SUPPORT
Adding mouse support in the terminal version of Emacs.

#+begin_src emacs-lisp
;; should be moved to dedicated function
;; (add-to-list 'load-path "~/.config/doom/lisp/")
;; (require 'cg-utils)  ;; or (load "cg-utils.el")

(defun cg/toggle-mouse-and-line-numbers ()
  "Toggle xterm-mouse-mode and line numbers together.
When mouse mode is disabled, also disable line numbers for easier copy-paste."
  (interactive)
  (if xterm-mouse-mode
      (progn
        (xterm-mouse-mode -1)
        (display-line-numbers-mode -1)
        (message "xterm-mouse-mode OFF, line numbers OFF"))
    (xterm-mouse-mode 1)
    (display-line-numbers-mode 1)
    (message "xterm-mouse-mode ON, line numbers ON")))

(unless (display-graphic-p)
  (map! :leader
        (:prefix ("t" . "toggle")
         :desc "Toggle xterm-mouse-mode" "M" #'cg/toggle-mouse-and-line-numbers )))
#+end_src

* NEOTREE

Neotree is a file tree viewer. When you open neotree, it jumps to the current
file thanks to neo-smart-open. The neo-window-fixed-size setting makes the
neotree width be adjustable. Doom Emacs had no keybindings set for neotree.
Since Doom Emacs uses 'SPC t' for 'toggle' keybindings, I used 'SPC t n' for
toggle-neotree.

| COMMAND        | DESCRIPTION               | KEYBINDING |
|----------------+---------------------------+------------|
| neotree-toggle | /Toggle neotree/            | SPC t n    |
| neotree- dir   | /Open directory in neotree/ | SPC d n    |

#+BEGIN_SRC emacs-lisp
(after! neotree
  (setq neo-smart-open t
        neo-window-fixed-size nil))
(after! doom-themes
  (setq doom-neotree-enable-variable-pitch t))
(map! :leader
      :desc "Toggle neotree file viewer" "t n" #'neotree-toggle
      :desc "Open directory in neotree"  "d n" #'neotree-dir)
#+END_SRC

* OPEN SPECIFIC FILES
Keybindings to open files that I work with all the time using the find-file command, which is the interactive file search that opens with 'C-x C-f' in GNU Emacs or 'SPC f f' in Doom Emacs.  These keybindings use find-file non-interactively since we specify exactly what file to open.  The format I use for these bindings is 'SPC =' plus 'key' since Doom Emacs does not use 'SPC ='.

=NOTE=: Doom Emacs already has a function 'doom/open-private-config' set to the keybinding 'SPC f p'.  This allows you to open any file in your HOME/.config/doom directory, so the following keybindings that I created are not really necessary, but I created this section as an example of how to to create bindings that open specific files on your system.

| PATH TO FILE                  | DESCRIPTION                 | KEYBINDING |
|-------------------------------+-----------------------------+------------|
| ~/.config/doom/start.org      | /Edit start.org (start page)/ | SPC = =    |
| ~/Dropbox/org/agenda.org      | /Edit agenda file/            | SPC = a    |
| ~/.config/doom/config.org     | /Edit doom config.org/        | SPC = c    |
| ~/.config/doom/init.el        | /Edit doom init.el/           | SPC = i    |
| ~/.config/doom/packages.el    | /Edit doom packages.el/       | SPC = p    |
| ~/.config/doom/eshell/aliases | /Edit eshell aliases/         | SPC = e a  |
| ~/.config/doom/eshell/profile | /Edit eshell profile/         | SPC = e p  |

#+BEGIN_SRC emacs-lisp
(map! :leader
      (:prefix ("=" . "open file")
       :desc "Edit agenda file"      "=" #'(lambda () (interactive) (find-file "~/.config/doom/start.org"))
       ;; :desc "Edit agenda file"      "a" #'(lambda () (interactive) (find-file "~/nc/Org/agenda.org"))
       :desc "Edit doom config.org"  "c" #'(lambda () (interactive) (find-file "~/.config/doom/config.org"))
       :desc "Edit doom init.el"     "i" #'(lambda () (interactive) (find-file "~/.config/doom/init.el"))
       :desc "Edit doom packages.el" "p" #'(lambda () (interactive) (find-file "~/.config/doom/packages.el"))))
(map! :leader
      (:prefix ("= e" . "open eshell files")
       :desc "Edit eshell aliases"   "a" #'(lambda () (interactive) (find-file "~/.config/doom/eshell/aliases"))
       :desc "Edit eshell profile"   "p" #'(lambda () (interactive) (find-file "~/.config/doom/eshell/profile"))))
#+END_SRC

 Note: commented out agenda.org

* ORG MODE

- *Org Agenda* displays tasks, deadlines, and scheduled items from files in `org-agenda-files`.
- *Org Capture* lets you quickly add entries to any Org file via templates.
  Captured tasks only appear in the agenda if their file is in `org-agenda-files`.
- *Journaling* can be done either with capture templates (single file)
  or with `org-journal` (daily files in a directory).
- *Org-roam* manages networked notes, separate from agenda and journal.

*** Current State

- Capture and journaling use separate files and locations.
- Only files in `org-agenda-files` contribute items to the agenda.
- Org-roam notes are not included in agenda or journal views.

*** Recommendation

- Unify journal and capture destinations if you want all entries together.
- Add all relevant files to `org-agenda-files` for a complete agenda view.

** Org-agenda

#+begin_src emacs-lisp
(after! org
    (setq org-agenda-files
        (list
         (joindirs org-directory "agenda.org")
         )
        ))
(setq
   ;; org-fancy-priorities-list '("[A]" "[B]" "[C]")
   ;; org-fancy-priorities-list '("❗" "[B]" "[C]")
   org-fancy-priorities-list '("🟥" "🟧" "🟨")
   org-priority-faces
   '((?A :foreground "#ff6c6b" :weight bold)
     (?B :foreground "#98be65" :weight bold)
     (?C :foreground "#c678dd" :weight bold))
   org-agenda-block-separator 8411)

(setq org-agenda-custom-commands
      '(("v" "A better agenda view"
         ((tags "PRIORITY=\"A\""
                ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                 (org-agenda-overriding-header "High-priority unfinished tasks:")))
          (tags "PRIORITY=\"B\""
                ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                 (org-agenda-overriding-header "Medium-priority unfinished tasks:")))
          (tags "PRIORITY=\"C\""
                ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                 (org-agenda-overriding-header "Low-priority unfinished tasks:")))
          (tags "customtag"
                ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                 (org-agenda-overriding-header "Tasks marked with customtag:")))

          (agenda "")
          (alltodo "")))))
#+end_src

** Org-Journal

| COMMAND               | DESCRIPTION             | KEYBINDING |
|-----------------------+-------------------------+------------|
| org-journal-new-entry | Add a new journal entry | SPC n j j  |

#+begin_src emacs-lisp
(setq org-journal-dir (joindirs org-directory "journal")
      org-journal-date-prefix "#+TITLE: "
      org-journal-time-prefix "* "
      org-journal-date-format "%A, %-d. %B %Y"
      org-journal-file-format "%Y-%m-%d.org")
#+end_src

** Org and latex inline images

| Keybinding | Action                       |
|------------+------------------------------|
| SPC m v l  | Toggle LaTeX fragment images |
| SPC m v i  | Toggle inline images         |

Nicer formula

#+begin_src emacs-lisp
(setq org-preview-latex-default-process 'dvisvgm)
(after! org
  (map! :map org-mode-map
        :localleader
        (:prefix ("v" . "view/toggle")
         :desc "Toggle LaTeX fragments" "l" #'org-toggle-latex-fragment
         :desc "Toggle inline images"   "i" #'org-toggle-inline-images)))
#+end_src

** Org-roam
[[https://github.com/org-roam/org-roam][Org-roam]] is a plain-text knowledge management system.  Org-roam borrows principles from the =Zettelkasten= method, providing a solution for non-hierarchical note-taking.  It should also work as a plug-and-play solution for anyone already using Org-mode for their personal wiki.

| COMMAND                | DESCRIPTION                        | KEYBINDING |
|------------------------+------------------------------------+------------|
| completion-at-point    | /Completion of node-insert at point/ | SPC n r c  |
| org-roam-node-find     | /Find node or create a new one/      | SPC n r f  |
| org-roam-graph         | /Show graph of all nodes/            | SPC n r g  |
| org-roam-node-insert   | /Insert link to a node -> backlink/  | SPC n r i  |
| org-roam-capture       | /Capture to node/                    | SPC n r n  |
| org-roam-buffer-toggle | /Toggle roam buffer/                 | SPC n r r  |

#+begin_src emacs-lisp

(after! org
  (when (display-graphic-p)
    (setq org-roam-directory (expand-file-name "roam" org-directory)
          org-roam-graph-viewer "/usr/bin/google-chrome")))

(map! :leader
      (:prefix ("n r" . "org-roam")
       :desc "Completion at point" "c" #'completion-at-point
       :desc "Find node"           "f" #'org-roam-node-find
       :desc "Show graph"          "g" #'org-roam-graph
       :desc "Insert node"         "i" #'org-roam-node-insert
       :desc "Capture to node"     "n" #'org-roam-capture
       :desc "Toggle roam buffer"  "r" #'org-roam-buffer-toggle))

#+end_src

** Other exporters

#+begin_src emacs-lisp
(use-package! ox-gfm
  :after org)
#+end_src

** Org-auto-tangle
=org-auto-tangle= allows you to add the option =#+auto_tangle: t= in your Org file so that it automatically tangles when you save the document.  I have made adding this to your file even easier by creating a function 'dt/insert-auto-tangle-tag' and setting it to a keybinding 'SPC i a'.

#+begin_src emacs-lisp
(use-package! org-auto-tangle
  :defer t
  :hook (org-mode . org-auto-tangle-mode)
  :config
  (setq org-auto-tangle-default t))

(defun dt/insert-auto-tangle-tag ()
  "Insert auto-tangle tag in a literate config."
  (interactive)
  (evil-org-open-below 1)
  (insert "#+auto_tangle: t ")
  (evil-force-normal-state))

(map! :leader
      :desc "Insert auto_tangle tag" "i a" #'dt/insert-auto-tangle-tag)
#+end_src

* PERSPECTIVE
Perspective provides multiple named workspaces (or "perspectives") in Emacs, similar to having multiple desktops in window managers like Awesome and XMonad.  Each perspective has its own buffer list and its own window layout, making it easy to work on many separate projects without getting lost in all the buffers.  Switching to a perspective activates its window configuration, and when in a perspective, only its buffers are available (by default).  Doom Emacs uses 'SPC some_key' for binding some of the perspective commands, so I used this binging format for the perspective bindings that I created..

| COMMAND                    | DESCRIPTION                         | KEYBINDING |
|----------------------------+-------------------------------------+------------|
| persp-switch               | /Switch to perspective NAME/          | SPC DEL    |
| persp-switch-to-buffer     | /Switch to buffer in perspective/     | SPC ,      |
| persp-next                 | /Switch to next perspective/          | SPC ]      |
| persp-prev                 | /Switch to previous perspective/      | SPC [      |
| persp-add-buffer           | /Add a buffer to current perspective/ | SPC +      |
| persp-remove-by-name       | /Remove perspective by name/          | SPC -      |
| +workspace/switch-to-{0-9} | /Switch to workspace n/               | SPC 0-9    |

#+begin_src emacs-lisp
(map! :leader
      :desc "Switch to perspective NAME"       "DEL" #'persp-switch
      :desc "Switch to buffer in perspective"  "," #'persp-switch-to-buffer
      :desc "Switch to next perspective"       "]" #'persp-next
      :desc "Switch to previous perspective"   "[" #'persp-prev
      :desc "Add a buffer current perspective" "+" #'persp-add-buffer
      :desc "Remove perspective by name"       "-" #'persp-remove-by-name)
#+end_src

* Project

#+begin_src emacs-lisp
(map! :leader
      :desc "Projectile run shell" "p S" #'projectile-run-shell
      :desc "Open eshell here"     "p E" #'eshell
      :desc "Open term here"       "p T" (cmd! (let ((default-directory (projectile-project-root))) (term (getenv "SHELL")))))
#+end_src

* LSP (Language Server Protocol)

** General LSP Configuration
#+begin_src emacs-lisp
(after! lsp-mode
  ;; General LSP settings
  (setq lsp-enable-file-watchers nil
        lsp-file-watch-threshold 2000
        lsp-idle-delay 0.500
        lsp-log-io nil))
#+end_src

** LSP UI Configuration  
#+begin_src emacs-lisp
(after! lsp-ui
  (setq lsp-ui-doc-enable t)
  (setq lsp-ui-doc-position 'top)
  (setq lsp-ui-doc-use-childframe nil)
  (setq lsp-ui-peek-enable nil)
  (setq lsp-ui-doc-show-with-cursor t)
  (setq lsp-ui-sideline-enable nil)
  ;; (setq lsp-ui-doc-position 'at-point)
  ;; (setq lsp-ui-doc-use-webkit t)
  ;; (setq lsp-ui-doc-maximum-width 150)
  ;; (setq lsp-ui-doc-maximum-height 35)
  ;; (setq lsp-ui-doc-header "Documentation")
  ;; (setq lsp-ui-sideline-enable t)
  ;; (setq lsp-ui-sideline-show-hover nil)
  ;; (setq lsp-ui-doc-show-with-cursor t)
  ;; (setq lsp-ui-doc-use-childframe nil)
  )
#+end_src

** Language-Specific LSP Settings

*** Python (Pyright)
#+begin_src emacs-lisp
(after! lsp-mode
  (setq lsp-pyright-python-executable-cmd "python" ;; or path to your venv's python
        lsp-pyright-typechecking-mode "basic"))     ;; optional, for type checking level
#+end_src

* Python

#+begin_src emacs-lisp
;; Python-specific settings (non-LSP)
#+end_src
* RAINBOW MODE
Rainbox mode displays the actual color for any hex value color.  It's such a nice feature that I wanted it turned on all the time, regardless of what mode I am in.  The following creates a global minor mode for rainbow-mode and enables it (exception: org-agenda-mode since rainbow-mode destroys all highlighting in org-agenda).

#+begin_src emacs-lisp
(define-globalized-minor-mode global-rainbow-mode rainbow-mode
  (lambda ()
    (when (not (memq major-mode
                (list 'org-agenda-mode)))
     (rainbow-mode 1))))
(global-rainbow-mode 1 )
#+end_src

* REGISTERS
Emacs registers are compartments where you can save text, rectangles and
positions for later use. Once you save text or a rectangle in a register, you
can copy it into the buffer once or many times; once you save a position in a
register, you can jump back to that position once or many times. The default GNU
Emacs keybindings for these commands (with the exception of consult-register)
involves 'C-x r' followed by one or more other keys. I wanted to make this a
little more user friendly, and since I am using Doom Emacs, I choose to replace
the 'C-x r' part of the key chords with 'SPC r'.

| COMMAND                          | DESCRIPTION                      | KEYBINDING |
|----------------------------------+----------------------------------+------------|
| copy-to-register                 | /Copy to register/                 | SPC r c    |
| frameset-to-register             | /Frameset to register/             | SPC r f    |
| insert-register                  | /Insert contents of register/      | SPC r i    |
| jump-to-register                 | /Jump to register/                 | SPC r j    |
| list-registers                   | /List registers/                   | SPC r l    |
| number-to-register               | /Number to register/               | SPC r n    |
| consult-register                 | /Interactively choose a register/  | SPC r r    |
| view-register                    | /View a register/                  | SPC r v    |
| window-configuration-to-register | /Window configuration to register/ | SPC r w    |
| increment-register               | /Increment register/               | SPC r +    |
| point-to-register                | /Point to register/                | SPC r SPC  |

#+BEGIN_SRC emacs-lisp
(map! :leader
      (:prefix ("r" . "registers")
       :desc "Copy to register" "c" #'copy-to-register
       :desc "Frameset to register" "f" #'frameset-to-register
       :desc "Insert contents of register" "i" #'insert-register
       :desc "Jump to register" "j" #'jump-to-register
       :desc "List registers" "l" #'list-registers
       :desc "Number to register" "n" #'number-to-register
       :desc "Interactively choose a register" "r" #'consult-register
       :desc "View a register" "v" #'view-register
       :desc "Window configuration to register" "w" #'window-configuration-to-register
       :desc "Increment register" "+" #'increment-register
       :desc "Point to register" "SPC" #'point-to-register))
#+END_SRC

* SHELLS
Settings for the various shells and terminal emulators within Emacs.

| COMMAND             | DESCRIPTION                | KEYBINDING |
|---------------------+----------------------------+------------|
| eshell              | /Launch the eshell/          | SPC e s    |
| +eshell/toggle      | /Toggle eshell popup window/ | SPC e t    |
| counsel-esh-history | /Browse the eshell history/  | SPC e h    |
| +vterm/toggle       | /Toggle vterm popup window/  | SPC v t    |


I am noch using ~fish~ as my shell as it is often not installed!

#+BEGIN_SRC emacs-lisp
(setq shell-file-name "/bin/bash"
      vterm-max-scrollback 5000)
(setq eshell-rc-script "~/.config/doom/eshell/profile"
      eshell-aliases-file "~/.config/doom/eshell/aliases"
      eshell-history-size 5000
      eshell-buffer-maximum-lines 5000
      eshell-hist-ignoredups t
      eshell-scroll-to-bottom-on-input t
      eshell-destroy-buffer-when-process-dies t
      eshell-visual-commands'("bash" "fish" "htop" "ssh" "top" "zsh"))
(map! :leader
      :desc "Eshell"                 "e s" #'eshell
      :desc "Eshell popup toggle"    "e t" #'+eshell/toggle
      :desc "Counsel eshell history" "e h" #'counsel-esh-history
      :desc "Vterm popup toggle"     "v t" #'+vterm/toggle)
#+END_SRC

* Search

I liked the feature in helm that allowed me to
have a word under cursor highlighted
that then would be the input to search functions like
`helm-swoop`, `helm-find-file` etc.
This is is the first step in that direction for the `consult`
system that I am using now.

Limitations:

- Not working for words marked with `*` yet.
- =helm= swooping was also nicer in a second respect: navigating across buffers

#+BEGIN_SRC emacs-lisp
(defun cg/consult-dwim-input (orig-fn &rest args)
  "Advice to use region, Evil search word, or word at point as initial input."
  (let* ((region (when (use-region-p)
                   (buffer-substring-no-properties (region-beginning) (region-end))))
         (evil-search (when (and (boundp 'evil-ex-search-pattern)
                                 evil-ex-search-pattern)
                        (car evil-ex-search-pattern)))
         (word (thing-at-point 'word t))
         (input (or region evil-search word)))
    (apply orig-fn (append (butlast args) (list input)))))

;; Only apply advice to specific functions, not consult-line which affects SPC s b
(dolist (fn '(consult-ripgrep consult-grep consult-find))
  (advice-add fn :around #'cg/consult-dwim-input))
#+END_SRC

* START PAGE
Instead of using Doom's Dashboard or the Emacs Dashboard program, I have decided
to just set an custom start file as my "dashboard" since it allows me more
customization options. I have added to the 'start-mode-hook' the argument
'read-only-mode'. This is to prevent accidental editing of the start file, and
to prevent clashes with the 'start-mode' specific keybindings. You can toggle
on/off read-only-mode with 'SPC t r'.

#+begin_src emacs-lisp
(setq initial-buffer-choice "~/.config/doom/start.org")

(define-minor-mode start-mode
  "Provide functions for custom start page."
  :lighter " start"
  :keymap (let ((map (make-sparse-keymap)))
          ;;(define-key map (kbd "M-z") 'eshell)
            (evil-define-key 'normal start-mode-map
              (kbd "1") '(lambda () (interactive) (find-file "~/.config/doom/config.org"))
              (kbd "2") '(lambda () (interactive) (find-file "~/.config/doom/init.el"))
              (kbd "3") '(lambda () (interactive) (find-file "~/.config/doom/packages.el"))
              (kbd "4") '(lambda () (interactive) (find-file "~/.config/doom/eshell/aliases"))
              (kbd "5") '(lambda () (interactive) (find-file "~/.config/doom/eshell/profile")))
          map))

(add-hook 'start-mode-hook 'read-only-mode) ;; make start.org read-only; use 'SPC t r' to toggle off read-only.
(provide 'start-mode)
#+end_src

* THEMING

#+begin_src emacs-lisp
(setq doom-theme 'doom-henna)
(map! :leader
      :desc "Load new theme" "h t" #'consult-theme)
#+end_src
* TREESITTER

I have installed the *treesitter* language grammar manually using =treesitter-install-language-grammar=.
Allegedly this will do it automaticalls:

#+begin_src emacs-lisp
(after! treesit
  (unless (treesit-language-available-p 'python)
    (treesit-install-language-grammar 'python)))
#+end_src

* WINNER MODE
Winner mode has been included with GNU Emacs since version 20.  This is a global minor mode and, when activated, it allows you to “undo” (and “redo”) changes in the window configuration with the key commands 'SCP w <left>' and 'SPC w <right>'.

#+BEGIN_SRC emacs-lisp
(map! :leader
      (:prefix ("w" . "window")
       :desc "Winner redo" "<right>" #'winner-redo
       :desc "Winner undo" "<left>"  #'winner-undo))
#+END_SRC

* ZAP TO CHAR
Emacs provides a 'zap-to-char' command that kills from the current point to a character.  It is bound to 'M-z' in standard GNU Emacs but since Doom Emacs uses 'SPC' as its leader key and does not have 'SPC z' binded to anything, it just makes since to use it for 'zap-to-char'.  Note that 'zap-to-char' can be used with the universal argument 'SPC u' to modify its behavior.  Examples of 'zap-to-char' usage are listed in the table below:

| KEYBINDING                | WHAT IS DOES                                               |
|---------------------------+------------------------------------------------------------|
| SPC z e                   | /deletes all chars to the next occurrence of 'e'/            |
| SPC u 2 SPC z e           | /deletes all chars to the second occurrence of 'e'/          |
| SPC u - SPC z e           | /deletes all chars to the previous occurrence of 'e'/        |
| SPC u - 2 SPC z e         | /deletes all chars to the second previous occurrence of 'e'/ |
| SPC u 1 0 0 SPC u SPC z e | /deletes all chars to the 100th occurrence of 'e'/           |

=TIP=: The universal argument (SPC u) can only take a single integer by default.  If you need to use a multi-digit number (like 100 in the last example in the table above), then you must terminate the universal argument with another 'SPC u' after typing the number.

'zap-up-to-char' is an alternative command that does not zap the char specified.  It is binded to 'SPC Z'.  It can also be used in conjunction with the universal argument 'SPC u' in similar fashion to the the 'zap-to-char' examples above.

=NOTE=:  Vim (evil mode) has similar functionality builtin.  You can delete to the next occurrence of 'e' by using 'dte' in normal.  To delete to the next occurrence of 'e' including the 'e', then you would use 'dfe'.  And you can modify 'dt' and 'df' by prefixing them with numbers, so '2dte' would delete to the second occurrence of 'e'.

#+BEGIN_SRC emacs-lisp
(map! :leader
      :desc "Zap to char"    "z" #'zap-to-char
      :desc "Zap up to char" "Z" #'zap-up-to-char)
#+END_SRC

* OTHER FILE STUFF

#+begin_src emacs-lisp
(map! :leader
      :desc "Find file at point"
      "f ." #'find-file-at-point)
#+end_src
* PASS - Manage Secrets using the default unix password manager

** Using Pass

Use Emacs's `password-store` integration to read secrets from your system
password store (pass) instead of hardcoding keys.

_What is `password-store-get`?__ It reads a secret from pass. Example:
`(password-store-get "code/openai_api_key")` returns the value stored at that
pass path.


*** Pass Hierarchy Layout

1. Use a context first approach:

#+begin_example
personal/api/anthropic/personal
work/aud/api/anthropic/main
personal/api/search/brave
personal/library/munich/city
work/aud/accounts/github/your-handle
work/aud/cloud/aws/prod/billing
#+end_example

2. Lowercase paths, hyphen-separated, no spaces.

Provider names canonical: anthropic, openai, xai, brave, pplx.
If multiple accounts per provider, add a short account label at the end (personal, main, aud, test).

**** GPG recipients and sharing

You can assign different recipients per subtree:
Initialize per-subtree:

#+begin_example
pass init -p personal <YOUR_KEYID>
pass init -p work/aud <YOUR_KEYID> <WORK_KEYID(S)>
#+end_example

*** Prerequisites (Linux)
#+begin_example
sudo apt install pass gnupg        # Debian/Ubuntu
#+end_example
*** Find your GPG key ID (if you already have keys)
The "key ID" is the identifier for your GPG key. List your keys with a long key
id:

#+begin_example
gpg --list-keys --keyid-format LONG
#+end_example

Look for a line like:

  pub   rsa4096/ABCDEF1234567890 2024-01-01 [SC]

- __Key ID__: the part after the slash (`ABCDEF1234567890`). You can also use your
  key's email (UID) instead of the ID in the next steps.

If you have no keys yet, create one:

#+begin_example
gpg --full-generate-key
#+end_example
*** Initialize pass

Initialize the password store with your key (use the long key ID or your GPG
email):

#+begin_example
pass init ABCDEF1234567890   # or: pass init your.email@example.com
#+end_example

*** Manually store a key in pass

#+begin_example
pass insert -m code/mykey
# paste your key, then press Enter, then Ctrl-D (or Enter twice) to finish
#+end_example

Verify you can read it:

#+begin_example
pass show code/mykey
#+end_example

*** Enable Emacs integration

- Doom module (recommended): enable `:tools pass` in `~/.config/doom/init.el`,
  then run `doom sync` and restart Emacs.
- Or install the `password-store` package yourself if not using the Doom module.

*** Use Verify Variables

Verify inside Emacs:

#+begin_src emacs-lisp
(getenv "OPENAI_API_KEY")
;; or
(password-store-get "code/openai_api_key")
#+end_src

#+RESULTS:

*** Quick setup cheat sheet (trust + init + insert + show)

Run these in a terminal. Replace the key ID if yours is different.

#+begin_example
gpg --edit-key ${GPG_KEY_ID}
# at the gpg prompt:
trust
# choose: 5 (ultimate)
# confirm: y
save
#+end_example

Initialize pass for your key (whole store):

#+begin_example
pass init ${GPG_KEY_ID}
#+end_example

Optional: initialize only the "code/" subtree:

#+begin_example
pass init -p code ${GPG_KEY_ID}
#+end_example

** Idempotently insert keys into pass store

#+begin_src emacs-lisp

;;; ========== pass bulk insert core (idempotent) ===========
(defun cg/pass--ensure ()
  (or (executable-find "pass")
      (user-error "pass(1) not found. Install and initialize pass + GPG")))

(defun cg/pass--existing-first-line (path)
  "Return first line of existing pass entry PATH, or nil if missing/error."
  (let (out)
    (with-temp-buffer
      (let ((status (call-process "pass" nil t nil "show" path)))
        (when (and (integerp status) (= status 0))
          (goto-char (point-min))
          (when (re-search-forward "\\`\\([^\n\r]+\\)" nil t)
            (setq out (match-string 1))))))
    out))

(defun cg/pass--insert (path secret &optional force)
  "Insert SECRET at PATH via pass. If FORCE, overwrite."
  (let ((pass (cg/pass--ensure)))
    (with-temp-buffer
      (insert secret "\n")
      (let* ((args (append '("insert" "-m") (when force '("-f")) (list path)))
             (status (apply #'call-process-region (point-min) (point-max)
                            pass nil nil nil args)))
        (unless (and (integerp status) (= status 0))
          (user-error "pass insert failed (status %S) for %s" status path))))))

(defun cg/pass-upsert (path secret &optional force)
  "Idempotent insert: if PATH exists and equals SECRET, do nothing.
If different, overwrite when FORCE non-nil; otherwise prompt."
  (let ((existing (cg/pass--existing-first-line path)))
    (cond
     ((and existing (string= existing secret))
      (message "pass: %s already set; skipping" path))
     ((and existing (not force))
      (when (y-or-n-p (format "pass: %s exists and differs. Overwrite? " path))
        (cg/pass--insert path secret t)
        (message "pass: %s updated" path)))
     (t
      (cg/pass--insert path secret force)
      (message "pass: %s inserted" path)))))

;;; ========== bulk from encrypted file ==========
(defun cg/pass-bulk-insert-from-file (file &optional force symbol)
  "Load FILE (e.g. ~/.config/doom/my-secrets.el.gpg) and upsert all entries.
FILE must define an alist variable. SYMBOL (default: cg/private-pass-secrets)
is the variable name to read. With FORCE, overwrite without prompting."
  (interactive
   (list (read-file-name "Secrets file: " "~/.config/doom/" nil t nil
                         (lambda (f) (string-match-p "\\.el\\(\\.gpg\\)?\\'" f)))
         current-prefix-arg
         (intern (completing-read "Var symbol: "
                                  '(cg/private-pass-secrets cg/api-keys)
                                  nil t nil nil "cg/private-pass-secrets"))))
  (let ((sym (or symbol 'cg/private-pass-secrets)))
    (unless (file-readable-p file)
      (user-error "Secrets file not readable: %s" file))
    (load file nil t)
    (unless (boundp sym)
      (user-error "Variable %s not defined in %s" sym file))
    (cg/pass-bulk-insert-from-var (symbol-value sym) force)))

;;; ========== bulk from variable (defvar cg/api-keys ...) ==========
(defun cg/pass-bulk-insert-from-var (alist &optional force)
  "Upsert all (PATH . SECRET) pairs from ALIST into pass.
With FORCE, overwrite differing entries without prompting."
  (interactive
   (list (let* ((sym (intern (completing-read "Var symbol: "
                                              obarray
                                              (lambda (s)
                                                (and (boundp s)
                                                     (listp (symbol-value s))))
                                              t nil nil "cg/api-keys"))))
           (symbol-value sym))
         current-prefix-arg))
  (unless (and (listp alist)
               (cl-every (lambda (x)
                           (and (consp x)
                                (stringp (car x))
                                (stringp (cdr x))))
                         alist))
    (user-error "Expected an alist of (PATH . SECRET) strings"))
  (dolist (cell alist)
    (cg/pass-upsert (car cell) (cdr cell) force)))
#+end_src

** PASS end environment variables from ENV

*** 1. Create a mapping

use defvar if it does not exist, and setq if it exists

#+begin_src emacs-lisp
(setq cg/secret-specs
  '((anthropic-aud
     :pass "code/anthropic_api_key_aud"
     :env  ("ANTHROPIC_API_KEY"))     ; optionally also "ANTHROPIC_API_KEY"
    (anthropic-personal
     :pass "code/anthropic_api_key_personal"
     :env  ("ANTHROPIC_API_KEY_PERSONAL"))
    (xai
     :pass "code/xai_api_key"
     :env  ("XAI_API_KEY"))
    (perplexity
     :pass "code/perplexity_api_key"
     :env  ("PPLX_API_KEY"))
    (openai-personal
     :pass "code/openai_api_key"
     :env  "OPENAI_API_KEY"))
  )
#+end_src

#+RESULTS:
| anthropic-aud      | :pass | code/anthropic_api_key_aud      | :env | (ANTHROPIC_API_KEY)          |
| anthropic-personal | :pass | code/anthropic_api_key_personal | :env | (ANTHROPIC_API_KEY_PERSONAL) |
| xai                | :pass | code/xai_api_key                | :env | (XAI_API_KEY)                |
| perplexity         | :pass | code/perplexity_api_key         | :env | (PPLX_API_KEY)               |
| openai-personal    | :pass | code/openai_api_key             | :env | OPENAI_API_KEY               |

*** 2) Export to Emacs env from pass
Idempotently set env vars in the current Emacs based on pass entries in ~cg/secret-specs~:
#+begin_src emacs-lisp
#+end_src

#+RESULTS:
: cg/export-env-from-pass

*** 3. Generate a shell snippet for .bashrc (safe, via pass at runtime)
This writes a script that reads secrets from pass at shell startup (no plaintext secrets on disk):
#+begin_src emacs-lisp
(defun cg/write-pass-export-script (file)
  "Write a script exporting env vars by reading pass at shell init time."
  (interactive "FWrite export script: ")
  (let ((lines (list "#!/usr/bin/env bash"
                     "set -euo pipefail" "")))
    (dolist (cell cg/secret-specs)
      (let* ((spec (cdr cell))
             (path (plist-get spec :pass))
             (envs (let ((e (plist-get spec :env))) (if (listp e) e (list e)))))
        (dolist (name envs)
          (push (format "export %s=\"$(pass show %s | head -n1)\"" name path)
                lines))))
    (with-temp-file file
      (insert (mapconcat #'identity (nreverse lines) "\n")))
    (set-file-modes file #o600)
    (message "Wrote %s (mode 600). Add 'source %s' to your shell rc." file file)))
#+end_src

#+RESULTS:
: cg/write-pass-export-script

** MIGRATION to better hierarchy


1. Modify Mapping between secrets and env vars, e.g.
#+begin_example emacs-lisp
(defvar cg/secret-specs
  '(
    (anthropic-personal
     :pass "personal/api/anthropic/personal"
     :env  ("ANTHROPIC_API_KEY"))
    (anthropic-work-aud
     :pass "work/aud/api/anthropic/main"
     :env  ("ANTHROPIC_API_KEY_AUD"))
    (xai-personal
     :pass "personal/api/xai"
     :env  ("XAI_API_KEY"))
    (perplexity-personal
     :pass "personal/api/search/perplexity"
     :env  ("PPLX_API_KEY"))
    (brave-personal
     :pass "personal/api/search/brave"
     :env  ("BRAVE_API_KEY"))
  ))
#+end_example


2. Then migrate like this:

#+begin_example
Migration plan (safe, reversible)
Backup the store (pass uses git by default):
pass git status
pass git branch restructure-$(date +%F)
pass git commit -am "pre-restructure snapshot"
Move entries to the new structure:
pass mv code/anthropic_api_key_personal personal/api/anthropic/personal
pass mv code/anthropic_api_key_aud work/aud/api/anthropic/main
pass mv code/perplexity_api_key personal/api/search/perplexity
pass mv code/xai_api_key personal/api/xai
Remove the old “code/” subtree when empty: pass rm -rf code
Optionally re-init subtrees with recipients:
pass init -p personal YOUR_KEYID
pass init -p work/aud YOUR_KEYID WORK_KEYID
Update cg/secret-specs with new paths.
Re-generate shell exports if you use them:
M-x cg/write-pass-export-script → source it in .bashrc
Optional: metadata lines in pass entries
If you prefer to keep env names near the secrets, add key=value pairs on following lines in the pass entry:

Example:
Line 1: the secret
Line 2+: env=ANTHROPIC_API_KEY
You can later parse those to generate exports, but since you already have cg/secret-specs, keeping metadata in Emacs is simpler and VCS-friendly.
When to use separate stores
If you want hard isolation between personal and work:

Use separate stores via PASSWORD_STORE_DIR (e.g., ~/.password-store-personal, ~/.password-store-work) and shell aliases/wrappers.
For most workflows, subtree recipients (pass init -p) are sufficient.
#+end_example

* AI/LMMS

uv tool install --force --python python3.12 --with pip aider-chat@latest
uv tool update-shell


;; After adding this configuration:
;; 1. Run: doom sync
;; 2. Restart Emacs
;; 3. Run: M-x copilot-install-server
;; 4. Run: M-x copilot-login
;; 5. Set your environment variables:
;;    - OPENAI_API_KEY for AiderMacs and GPTel
;;    - ANTHROPIC_API_KEY for Claude (optional)
;; 6. Test with: SPC k x T (toggle all AI tools)

;; Key Combinations Quick Reference:
;; SPC k c t - Toggle Copilot
;; SPC k a s - Start Aider
;; SPC k g n - New GPT chat
;; SPC k x r - AI Code Review
;; SPC k x e - Explain Code
;; SPC k x R - Refactor with Aider
;; TAB - Accept Copilot suggestion

** Github Copilot Configuration

#+begin_src emacs-lisp
(use-package! copilot
  :hook (prog-mode . copilot-mode)
  :bind (:map copilot-completion-map
              ("<tab>" . copilot-accept-completion)
              ("TAB" . copilot-accept-completion)
              ("C-TAB" . copilot-accept-completion-by-word)
              ("C-<tab>" . copilot-accept-completion-by-word)
              ("C-c TAB" . copilot-accept-completion-by-line))
  :config
  ;; Customize copilot behavior
  (setq copilot-indent-offset-warning-disable t)

  ;; Show copilot suggestions with distinctive styling
  (set-face-attribute 'copilot-overlay-face nil
                      :foreground "#6272a4"
                      :background nil
                      :slant 'italic)

  ;; Auto-enable in specific modes
  (add-hook 'python-mode-hook 'copilot-mode)
  (add-hook 'js-mode-hook 'copilot-mode)
  (add-hook 'typescript-mode-hook 'copilot-mode)
  (add-hook 'rust-mode-hook 'copilot-mode)
  (add-hook 'go-mode-hook 'copilot-mode)
  (add-hook 'emacs-lisp-mode-hook 'copilot-mode)
  )
#+end_src

#+RESULTS:
: copilot-accept-completion-by-line

** AIdermacs Configuration

https://aider.chat/docs/config.html
https://github.com/Aider-AI/aider

# (add-hook 'aidermacs-before-run-backend-hook
#           (lambda ()
#             (setenv "OPENAI_API_KEY" (password-store-get "code/openai_api_key"))))

#+begin_src emacs-lisp
;; Secret management functions are now loaded from ~/emacs-conf/defuns/cg-secrets.el
#+end_src


#+begin_src emacs-lisp

(use-package! aidermacs
  :defer t  ; Defer loading until actually needed
  :init
  ;; Set up environment variables early, but safely
  (defun cg/ensure-secrets-loaded ()
    "Ensure secret management functions are available and set environment variables."
    (when (fboundp 'cg/set-env-from-secrets)
      (cg/set-env-from-secrets "OPENAI_API_KEY"     "code/openai_api_key"     "openai.com")
      (cg/set-env-from-secrets "ANTHROPIC_API_KEY"  "code/anthropic_api_key_personal"  "anthropic.com")
      (cg/set-env-from-secrets "XAI_API_KEY"        "code/xai_api_key"        "x.ai")
      (cg/set-env-from-secrets "PPLX_API_KEY"       "code/perplexity_api_key" "perplexity.ai")))

  :config
  ;; Initialize API keys when aidermacs is actually loaded
  (cg/ensure-secrets-loaded)

  ;; Customize aidermacs behavior
  ;; (setq aidermacs-model "gpt-4o")   ; or "claude-3-5-sonnet-20241022"
  (setq aidermacs-auto-commit nil)  ; Don't auto-commit changes
  (setq aidermacs-show-diffs t)     ; Always show diffs
  (setq aidermacs-show-diff-after-change nil) ; diffs after changes (default: t)
  (setq aidermacs-backend 'vterm)        ; aidermacs
  ;; Vterm backend:
  (setq aidermacs-vterm-multiline-newline-key "S-<return>")


  ;; Set up keys before any aidermacs command (with safety check)
  (advice-add 'aidermacs-start :before
              (lambda (&rest _)
                (cg/ensure-secrets-loaded)))

  (advice-add 'aidermacs-send-prompt :before
              (lambda (&rest _)
                (cg/ensure-secrets-loaded))))
#+end_src

#+RESULTS:
: t

** AI Rules system (Similar to .cursorrules)


#+begin_src emacs-lisp
(defvar cg/ai-global-rules
  "You are an expert software developer assistant. Follow these global rules:

1. CODING STANDARDS:
   - Write clean, readable, and maintainable code
   - Follow language-specific best practices and idioms
   - Use meaningful variable and function names
   - Add comments for complex logic only
   - Prefer composition over inheritance
   - Write self-documenting code

2. SECURITY:
   - Never expose API keys or sensitive data
   - Validate all inputs
   - Use secure coding practices
   - Consider potential security vulnerabilities

3. PERFORMANCE:
   - Write efficient algorithms
   - Avoid premature optimization
   - Consider memory usage and time complexity
   - Use appropriate data structures

4. TESTING:
   - Suggest testable code structure
   - Include error handling
   - Consider edge cases
   - Write defensive code

5. DOCUMENTATION:
   - Keep documentation concise but clear
   - Update documentation when changing code
   - Use consistent formatting"
  "Global AI rules applied to all AI interactions.")


(defvar cg/ai-project-rules nil
  "Buffer to store project-specific AI rules loaded from .aiderrules file.")
(defun cg/load-project-ai-rules ()
  "Load AI rules from .aiderrules file in project root."
  (let ((rules-file (expand-file-name ".aiderrules" (project-root (project-current)))))
    (when (file-exists-p rules-file)
      (setq cg/ai-project-rules
            (with-temp-buffer
              (insert-file-contents rules-file)
              (buffer-string)))
      (message "Loaded project AI rules from %s" rules-file))))

(defun cg/get-combined-ai-rules ()
  "Combine global and project-specific AI rules."
  (concat cg/ai-global-rules
          (when cg/ai-project-rules
            (concat "\n\nPROJECT-SPECIFIC RULES:\n" cg/ai-project-rules))))

(defun cg/create-aiderrules-template ()
  "Create a template .aiderrules file in project root."
  (interactive)
  (let* ((project-root (project-root (project-current)))
         (rules-file (expand-file-name ".aiderrules" project-root))
         (template-content "# Project-specific AI rules for this codebase
# This file defines how AI assistants should behave in this project

## Framework/Technology Stack
- Language: [e.g., Python, JavaScript, Rust]
- Framework: [e.g., React, Django, Actix]
- Architecture: [e.g., MVC, microservices, monolith]

## Code Style Preferences
- Indentation: [e.g., 2 spaces, 4 spaces, tabs]
- Line length: [e.g., 80, 100, 120 characters]
- Naming convention: [e.g., camelCase, snake_case, PascalCase]

## Project-Specific Guidelines
- Use our custom error handling pattern
- Follow our API response format
- Implement proper logging using our logger
- Add type hints/annotations where applicable
- Follow our testing patterns and file structure

## Dependencies and Libraries
- Prefer [specific libraries] for [specific tasks]
- Avoid [specific libraries] due to [reasons]
- Use our internal utilities instead of [alternatives]

## File Organization
- Follow our directory structure conventions
- Use consistent file naming patterns
- Group related functionality appropriately

## Additional Instructions
- Always consider backward compatibility
- Optimize for readability over cleverness
- Include proper error messages
- Consider internationalization where applicable"))
    (if (file-exists-p rules-file)
        (message ".aiderrules already exists in %s" project-root)
      (with-temp-file rules-file
        (insert template-content))
      (find-file rules-file)
      (message "Created .aiderrules template in %s" project-root))))

;; Auto-load project rules when switching projects
(add-hook 'project-switch-hook #'cg/load-project-ai-rules)

;; Load rules when opening files in a new project
(add-hook 'find-file-hook
          (lambda ()
            (when (and (project-current) (not cg/ai-project-rules))
              (cg/load-project-ai-rules))))
#+end_src

**  Enhanced AI functions with rules support

#+begin_src emacs-lisp
(defun cg/ai-send-with-rules (content prompt-type)
  "Send content to AI with appropriate rules prepended."
  (let ((full-prompt (concat (cg/get-combined-ai-rules)
                           "\n\n=== TASK ===\n"
                           prompt-type
                           "\n\n=== CODE ===\n"
                           content)))
    (with-current-buffer (get-buffer-create "*AI Assistant*")
      (erase-buffer)
      (insert full-prompt)
      (gptel-mode)
      (goto-char (point-max))
      (gptel-send))))
#+end_src

** Integrated AI workflow functions

#+begin_src emacs-lisp
(defun cg/ai-code-review ()
  "Send current buffer to GPTel for code review with rules."
  (interactive)
  (cg/ai-send-with-rules
   (buffer-string)
   "Please review this code for:
- Code quality and best practices
- Potential bugs or issues
- Performance improvements
- Security considerations
- Adherence to the specified rules and conventions"))

(defun cg/ai-explain-code ()
  "Explain selected code or function at point using GPTel with rules."
  (interactive)
  (let ((code (if (region-active-p)
                  (buffer-substring-no-properties (region-beginning) (region-end))
                (thing-at-point 'defun t))))
    (when code
      (cg/ai-send-with-rules
       code
       "Please explain this code in detail, considering the project context and rules."))))

(defun cg/ai-refactor-with-aider ()
  "Start aidermacs and suggest refactoring for current file with rules."
  (interactive)
  (cg/load-project-ai-rules)  ; Ensure rules are loaded
  (aidermacs-start)
  (sleep-for 2)  ; Wait for aider to start
  (let ((prompt (concat (cg/get-combined-ai-rules)
                       "\n\nPlease review and suggest refactoring improvements for "
                       (buffer-file-name)
                       ". Focus on code quality, maintainability, and adherence to the specified rules.")))
    (aidermacs-send-prompt prompt)))

(defun cg/ai-generate-code ()
  "Generate code based on user prompt with project rules."
  (interactive)
  (let ((user-prompt (read-string "Describe what code you need: ")))
    (cg/ai-send-with-rules
     (format "Current file: %s\nContext: %s"
             (or (buffer-file-name) "New file")
             (if (region-active-p)
                 (buffer-substring-no-properties (region-beginning) (region-end))
               "No specific context"))
     (concat "Generate code based on this request: " user-prompt))))

(defun cg/ai-fix-code ()
  "Fix code issues in current selection or buffer."
  (interactive)
  (let ((code (if (region-active-p)
                  (buffer-substring-no-properties (region-beginning) (region-end))
                (buffer-string))))
    (cg/ai-send-with-rules
     code
     "Please identify and fix any issues in this code. Provide the corrected version with explanations.")))

(defun cg/ai-optimize-code ()
  "Optimize selected code or buffer for performance."
  (interactive)
  (let ((code (if (region-active-p)
                  (buffer-substring-no-properties (region-beginning) (region-end))
                (buffer-string))))
    (cg/ai-send-with-rules
     code
     "Please optimize this code for better performance while maintaining readability and following the specified rules.")))

(defun cg/ai-add-tests ()
  "Generate tests for current function or class."
  (interactive)
  (let ((code (if (region-active-p)
                  (buffer-substring-no-properties (region-beginning) (region-end))
                (thing-at-point 'defun t))))
    (when code
      (cg/ai-send-with-rules
       code
       "Please generate comprehensive tests for this code. Include unit tests, edge cases, and error scenarios."))))

(defun cg/ai-add-documentation ()
  "Generate documentation for current function or class."
  (interactive)
  (let ((code (if (region-active-p)
                  (buffer-substring-no-properties (region-beginning) (region-end))
                (thing-at-point 'defun t))))
    (when code
      (cg/ai-send-with-rules
       code
       "Please generate appropriate documentation for this code. Include docstrings, parameter descriptions, and usage examples."))))

(defun cg/toggle-all-ai-tools ()
  "Toggle all AI tools on/off."
  (interactive)
  (copilot-mode 'toggle)
  (message "AI tools toggled: Copilot %s"
           (if copilot-mode "ON" "OFF")))
#+end_src

#+RESULTS:
: cg/toggle-all-ai-tools

** Enhanced Keybindings with Rules Support

#+begin_src emacs-lisp
(map! :leader
      (:prefix ("A" . "AI / LLM")
       ;; Copilot subgroup
       (:prefix ("c" . "Copilot")
        :desc "Toggle Copilot" "t" #'copilot-mode
        :desc "Accept completion" "a" #'copilot-accept-completion
        :desc "Next completion" "n" #'copilot-next-completion
        :desc "Previous completion" "p" #'copilot-previous-completion
        :desc "Clear completion" "c" #'copilot-clear-overlay
        :desc "Login" "l" #'copilot-login
        :desc "Diagnose" "d" #'copilot-diagnose)
       ;; Aider subgroup
       (:prefix ("a" . "Aider")
        :desc "aider" "a" #'aidermacs-transient-menu
        :desc "Start Aider" "s" #'aidermacs-run
        :desc "Stop Aider" "q" #'aidermacs-exit
        :desc "Send region" "r" #'aidermacs-send-region
        :desc "Send buffer" "b" #'aidermacs-send-buffer
        :desc "Send prompt" "p" #'aidermacs-send-prompt
        :desc "Show status" "S" #'aidermacs-status
        :desc "Clear context" "c" #'aidermacs-clear-context
        :desc "Add file" "f" #'aidermacs-add-file
        :desc "Remove file" "R" #'aidermacs-remove-file)
       ;; GPTel subgroup
       (:prefix ("g" . "GPTel")
        :desc "New Chat" "n" #'gptel)
       ;; Actions subgroup
       (:prefix ("x" . "AI Actions")
        :desc "Code Review" "r" #'cg/ai-code-review
        :desc "Explain Code" "e" #'cg/ai-explain-code
        :desc "Generate Code" "g" #'cg/ai-generate-code
        :desc "Fix Code" "f" #'cg/ai-fix-code
        :desc "Optimize Code" "o" #'cg/ai-optimize-code
        :desc "Add Tests" "t" #'cg/ai-add-tests
        :desc "Add Documentation" "d" #'cg/ai-add-documentation
        :desc "Refactor with Aider" "R" #'cg/ai-refactor-with-aider
        :desc "Toggle All AI" "T" #'cg/toggle-all-ai-tools)
       ;; Settings subgroup
       (:prefix ("s" . "AI Settings/Rules")
        :desc "Create .aiderrules" "r" #'cg/create-aiderrules-template
        :desc "Reload Rules" "R" #'cg/load-project-ai-rules
        :desc "Edit Global Rules" "g" (lambda () (interactive)
                                        (with-current-buffer (get-buffer-create "*AI Global Rules*")
                                          (erase-buffer)
                                          (insert cg/ai-global-rules)
                                          (markdown-mode)
                                          (switch-to-buffer (current-buffer)))))))

#+end_src

#+RESULTS:
: #[nil ((with-current-buffer (get-buffer-create "*AI Global Rules*") (erase-buffer) (insert cg/ai-global-rules) (markdown-mode) (switch-to-buffer (current-buffer)))) nil nil nil nil]

** Optional: Performance and UX Improvements

#+begin_src emacs-lisp
;; Make completions faster
(setq copilot-max-char -1)  ; No character limit for completions

;; Better integration with company-mode (if you use it)
(after! company
  (setq company-idle-delay 0.1)  ; Faster company popup
  ;; Ensure copilot doesn't conflict with company
  (add-hook 'copilot-mode-hook
            (lambda ()
              (setq-local company-idle-delay (if copilot-mode 0.5 0.1)))))

;; Auto-save before sending to AI tools
(defadvice aidermacs-send-buffer (before save-buffer-first activate)
  "Save buffer before sending to aider."
  (when (buffer-modified-p)
    (save-buffer)))
#+end_src

** Startup Configuration

#+begin_src emacs-lisp
;; Auto-start copilot in programming modes
(add-hook 'doom-first-buffer-hook
          (lambda ()
            (when (derived-mode-p 'prog-mode)
              (copilot-mode 1))))

;; Display AI status in modeline (optional)
(defun cg/ai-status-indicator ()
  "Show AI tools status in modeline."
  (concat
   (when (and (boundp 'copilot-mode) copilot-mode) " ⚡")
   (when (get-buffer "*aidermacs*") " 🤖")
   (when (and (boundp 'gptel-mode) gptel-mode) " 💬")))

;; Add to modeline (uncomment if desired)
;; (add-to-list 'mode-line-misc-info '(:eval (cg/ai-status-indicator)))
#+end_src

* YASNIPPET

#+begin_src emacs-lisp
(after! yasnippet
;; add multiple directories
(add-to-list 'yas-snippet-dirs (expand-file-name "snippets" doom-user-dir))
(yas-reload-all))
#+end_src

#+RESULTS:
